(in-package :utils)

(defun merge-with (fn alist)
  (let (res)
    (dolist (current alist res)
      (let ((val (cdr (assoc (car current) res :test #'equal))))
        (if (null val)
            (push current res)
            (rplacd (assoc (car current) res :test #'equal)
                    (funcall fn val (cdr current))))))))

(defun group-by (xs &optional (fn (lambda (x) x)))
  (let (res)
    (dolist (x xs res)
      (let* ((y (funcall fn x))
             (z (cdr (assoc y res))))
        (if (null z)
            (push (cons y (list x)) res)
            (setf (cdr (assoc y res))
                  (cons x z)))))))

(defmacro ->> (x &rest forms)
  (dolist (f forms x)
    (if (listp f)
        (setf x (append f (list x)))
        (setf x (list f x)))))

(defmacro -> (x &rest forms)
  (dolist (f forms x)
    (if (listp f)
        (setf x (append (list (car f) x) (cdr f)))
        (setf x (list f x))))) 

